<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>YASK: yask::yc_solution Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kernel: a software framework for creating HPC stencil code. Copyright 2014-2018 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yc__solution.html">yc_solution</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yc__solution-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yask::yc_solution Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yc.html">YASK Compiler</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stencil solution.  
 <a href="classyask_1_1yc__solution.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yask__compiler__api_8hpp_source.html">yask_compiler_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff540803d358a5dcd304f09c522ec867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aff540803d358a5dcd304f09c522ec867">set_debug_output</a> (<a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> debug)=0</td></tr>
<tr class="memdesc:aff540803d358a5dcd304f09c522ec867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object to receive debug output.  <a href="#aff540803d358a5dcd304f09c522ec867">More...</a><br /></td></tr>
<tr class="separator:aff540803d358a5dcd304f09c522ec867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b28b57b0774dd12c4a14744e124ece4"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a2b28b57b0774dd12c4a14744e124ece4">get_name</a> () const  =0</td></tr>
<tr class="memdesc:a2b28b57b0774dd12c4a14744e124ece4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the solution.  <a href="#a2b28b57b0774dd12c4a14744e124ece4">More...</a><br /></td></tr>
<tr class="separator:a2b28b57b0774dd12c4a14744e124ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfefccda72a3560e6664471a9ab451a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1dfefccda72a3560e6664471a9ab451a">set_name</a> (std::string name)=0</td></tr>
<tr class="memdesc:a1dfefccda72a3560e6664471a9ab451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the solution.  <a href="#a1dfefccda72a3560e6664471a9ab451a">More...</a><br /></td></tr>
<tr class="separator:a1dfefccda72a3560e6664471a9ab451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e6b5f4813d58de8ba4aedadc67874"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ae32e6b5f4813d58de8ba4aedadc67874">get_element_bytes</a> () const  =0</td></tr>
<tr class="memdesc:ae32e6b5f4813d58de8ba4aedadc67874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current floating-point precision setting.  <a href="#ae32e6b5f4813d58de8ba4aedadc67874">More...</a><br /></td></tr>
<tr class="separator:ae32e6b5f4813d58de8ba4aedadc67874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce565febd97f50efae59c37d7d5ef4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a6ce565febd97f50efae59c37d7d5ef4f">set_element_bytes</a> (int nbytes)=0</td></tr>
<tr class="memdesc:a6ce565febd97f50efae59c37d7d5ef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set floating-point precision.  <a href="#a6ce565febd97f50efae59c37d7d5ef4f">More...</a><br /></td></tr>
<tr class="separator:a6ce565febd97f50efae59c37d7d5ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d009c433e6d6501821ae01d37897802"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802">new_grid</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a6d009c433e6d6501821ae01d37897802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional grid variable in the solution.  <a href="#a6d009c433e6d6501821ae01d37897802">More...</a><br /></td></tr>
<tr class="separator:a6d009c433e6d6501821ae01d37897802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4e35274ef6d1401321f479a4b27ac9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1a4e35274ef6d1401321f479a4b27ac9">new_grid</a> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a1a4e35274ef6d1401321f479a4b27ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional grid variable in the solution.  <a href="#a1a4e35274ef6d1401321f479a4b27ac9">More...</a><br /></td></tr>
<tr class="separator:a1a4e35274ef6d1401321f479a4b27ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64b5f227726444c9a058cd36c05d3f8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aa64b5f227726444c9a058cd36c05d3f8">new_scratch_grid</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:aa64b5f227726444c9a058cd36c05d3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional scratch-grid variable in the solution.  <a href="#aa64b5f227726444c9a058cd36c05d3f8">More...</a><br /></td></tr>
<tr class="separator:aa64b5f227726444c9a058cd36c05d3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a47737698bd35da8f0516d8d1abac9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a79a47737698bd35da8f0516d8d1abac9">new_scratch_grid</a> (const std::string &amp;name, const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:a79a47737698bd35da8f0516d8d1abac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an n-dimensional scratch-grid variable in the solution.  <a href="#a79a47737698bd35da8f0516d8d1abac9">More...</a><br /></td></tr>
<tr class="separator:a79a47737698bd35da8f0516d8d1abac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1296849c882e96b972e70e762d3c86a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac1296849c882e96b972e70e762d3c86a">get_num_grids</a> () const  =0</td></tr>
<tr class="memdesc:ac1296849c882e96b972e70e762d3c86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of grids in the solution.  <a href="#ac1296849c882e96b972e70e762d3c86a">More...</a><br /></td></tr>
<tr class="separator:ac1296849c882e96b972e70e762d3c86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bdf1dd521c08bdc082677f5a4355b5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ab4bdf1dd521c08bdc082677f5a4355b5">get_grids</a> ()=0</td></tr>
<tr class="memdesc:ab4bdf1dd521c08bdc082677f5a4355b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the grids in the solution.  <a href="#ab4bdf1dd521c08bdc082677f5a4355b5">More...</a><br /></td></tr>
<tr class="separator:ab4bdf1dd521c08bdc082677f5a4355b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78ee81c7aeb385cbdb7fa91c01bdf76"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac78ee81c7aeb385cbdb7fa91c01bdf76">get_grid</a> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:ac78ee81c7aeb385cbdb7fa91c01bdf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified grid.  <a href="#ac78ee81c7aeb385cbdb7fa91c01bdf76">More...</a><br /></td></tr>
<tr class="separator:ac78ee81c7aeb385cbdb7fa91c01bdf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1168b5b8044e39c047d81a5fe5efc06e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a1168b5b8044e39c047d81a5fe5efc06e">set_fold_len</a> (const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> dim, int len)=0</td></tr>
<tr class="memdesc:a1168b5b8044e39c047d81a5fe5efc06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vectorization length in given dimension.  <a href="#a1168b5b8044e39c047d81a5fe5efc06e">More...</a><br /></td></tr>
<tr class="separator:a1168b5b8044e39c047d81a5fe5efc06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf489e67ed8cc753e999b1495dd4dde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#afaf489e67ed8cc753e999b1495dd4dde">clear_folding</a> ()=0</td></tr>
<tr class="memdesc:afaf489e67ed8cc753e999b1495dd4dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all vector-folding settings.  <a href="#afaf489e67ed8cc753e999b1495dd4dde">More...</a><br /></td></tr>
<tr class="separator:afaf489e67ed8cc753e999b1495dd4dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb1df4af6886e82f98904473873272"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a45cb1df4af6886e82f98904473873272">set_cluster_mult</a> (const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> dim, int mult)=0</td></tr>
<tr class="memdesc:a45cb1df4af6886e82f98904473873272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cluster multiplier (unroll factor) in given dimension.  <a href="#a45cb1df4af6886e82f98904473873272">More...</a><br /></td></tr>
<tr class="separator:a45cb1df4af6886e82f98904473873272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac4ddf5e4155d64cea2b39d5cb1e2435e">clear_clustering</a> ()=0</td></tr>
<tr class="memdesc:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all vector-clustering settings.  <a href="#ac4ddf5e4155d64cea2b39d5cb1e2435e">More...</a><br /></td></tr>
<tr class="separator:ac4ddf5e4155d64cea2b39d5cb1e2435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6094a75fe966ad339ffb034ea08674da"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a6094a75fe966ad339ffb034ea08674da">get_num_equations</a> () const  =0</td></tr>
<tr class="memdesc:a6094a75fe966ad339ffb034ea08674da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of equations in the solution.  <a href="#a6094a75fe966ad339ffb034ea08674da">More...</a><br /></td></tr>
<tr class="separator:a6094a75fe966ad339ffb034ea08674da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8257de64334bd95fcaca64719653fd1d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a8257de64334bd95fcaca64719653fd1d">get_equations</a> ()=0</td></tr>
<tr class="memdesc:a8257de64334bd95fcaca64719653fd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all the defined equations.  <a href="#a8257de64334bd95fcaca64719653fd1d">More...</a><br /></td></tr>
<tr class="separator:a8257de64334bd95fcaca64719653fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e606a7a3a3d3fee9d5758095065fd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#aa1e606a7a3a3d3fee9d5758095065fd2">format</a> (const std::string &amp;format_type, <a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> output)=0</td></tr>
<tr class="memdesc:aa1e606a7a3a3d3fee9d5758095065fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the current equation(s) and write to given output object.  <a href="#aa1e606a7a3a3d3fee9d5758095065fd2">More...</a><br /></td></tr>
<tr class="separator:aa1e606a7a3a3d3fee9d5758095065fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac181c24ab7af945318a055cef3b52ee6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#ac181c24ab7af945318a055cef3b52ee6">set_dependency_checker_enabled</a> (bool enable)=0</td></tr>
<tr class="memdesc:ac181c24ab7af945318a055cef3b52ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Enable or disable automatic dependency checker.  <a href="#ac181c24ab7af945318a055cef3b52ee6">More...</a><br /></td></tr>
<tr class="separator:ac181c24ab7af945318a055cef3b52ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a0f5b85744190a56c1a64b5eaaff9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a894a0f5b85744190a56c1a64b5eaaff9">is_dependency_checker_enabled</a> () const  =0</td></tr>
<tr class="memdesc:a894a0f5b85744190a56c1a64b5eaaff9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine whether automatic dependency checker is enabled.  <a href="#a894a0f5b85744190a56c1a64b5eaaff9">More...</a><br /></td></tr>
<tr class="separator:a894a0f5b85744190a56c1a64b5eaaff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727a91bb87e42de9822ac6540e3fc93e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e">add_flow_dependency</a> (<a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> from, <a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a> to)=0</td></tr>
<tr class="memdesc:a727a91bb87e42de9822ac6540e3fc93e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a dependency between two equations.  <a href="#a727a91bb87e42de9822ac6540e3fc93e">More...</a><br /></td></tr>
<tr class="separator:a727a91bb87e42de9822ac6540e3fc93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd08d7a26c93d5073134f3b76dcc38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yc__solution.html#a42cd08d7a26c93d5073134f3b76dcc38">clear_dependencies</a> ()=0</td></tr>
<tr class="memdesc:a42cd08d7a26c93d5073134f3b76dcc38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Remove all existing dependencies.  <a href="#a42cd08d7a26c93d5073134f3b76dcc38">More...</a><br /></td></tr>
<tr class="separator:a42cd08d7a26c93d5073134f3b76dcc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stencil solution. </p>
<p>Objects of this type contain all the grids and equations that comprise a solution. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aff540803d358a5dcd304f09c522ec867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_debug_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a>&#160;</td>
          <td class="paramname"><em>debug</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set object to receive debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">debug</td><td>Pointer to object to receive debug output. See <a class="el" href="classyask_1_1yask__output__factory.html">yask_output_factory</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b28b57b0774dd12c4a14744e124ece4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; yask::yc_solution::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the solution name provided via new_solution(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1dfefccda72a3560e6664471a9ab451a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name of the solution. </p>
<p>Allows changing the name from what was provided via new_solution(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name; must be a valid C++ identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae32e6b5f4813d58de8ba4aedadc67874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_element_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current floating-point precision setting. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in a FP number. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce565febd97f50efae59c37d7d5ef4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_element_bytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set floating-point precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes in a FP number. Should be 4 or 8. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d009c433e6d6501821ae01d37897802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> yask::yc_solution::new_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional grid variable in the solution. </p>
<p>"Grid" is a generic term for any n-dimensional variable. A 0-dim grid is a scalar, a 1-dim grid is a vector, a 2-dim grid is a matrix, etc.</p>
<p>At least one grid must be defined with a step-index node, and it must be the first dimension listed. If more than one grid uses a step-index node, the step-indices must have the same name across all such grids.</p>
<p>At least one grid must be defined with at least one domain-index node.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__grid.html">yc_grid</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Unique name of the grid; must be a valid C++ identifier and unique across grids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the grid. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a4e35274ef6d1401321f479a4b27ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> yask::yc_solution::new_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional grid variable in the solution. </p>
<p>C++ initializer-list version with same semantics as <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">new_grid(const std::string&amp; name, const std::vector&lt;yc_index_node_ptr&gt;&amp; dims)</a>. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__grid.html">yc_grid</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Unique name of the grid; must be a valid C++ identifier and unique across grids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the grid. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa64b5f227726444c9a058cd36c05d3f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> yask::yc_solution::new_scratch_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional scratch-grid variable in the solution. </p>
<p>A scratch grid is a temporary variable used in the definition of a non-scratch grid.</p><ul>
<li>Scratch grids are not accessible via kernel APIs. Thus, they cannot be programmatically read from or written to.</li>
<li>Scratch grid values must be defined from equations ultimately referencing only non-scratch grid values, optionally referencing other intermediate scratch-grids.</li>
<li>Scratch grids cannot use the step-index as a dimension.</li>
</ul>
<p>See <code>TestScratchStencil*</code> classes in <code>src/stencils/SimpleTestStencils.hpp</code> for usage examples.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__grid.html">yc_grid</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Unique name of the grid; must be a valid C++ identifier and unique across grids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the grid. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79a47737698bd35da8f0516d8d1abac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> yask::yc_solution::new_scratch_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an n-dimensional scratch-grid variable in the solution. </p>
<p>C++ initializer-list version with same semantics as <a class="el" href="classyask_1_1yc__solution.html#aa64b5f227726444c9a058cd36c05d3f8" title="Create an n-dimensional scratch-grid variable in the solution. ">new_scratch_grid(const std::string&amp; name, const std::vector&lt;yc_index_node_ptr&gt;&amp; dims)</a>. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="classyask_1_1yc__grid.html">yc_grid</a> object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Unique name of the grid; must be a valid C++ identifier and unique across grids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Dimensions of the grid. Each dimension is identified by an associated index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1296849c882e96b972e70e762d3c86a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_num_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of grids in the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of grids that have been created via <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">new_grid()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4bdf1dd521c08bdc082677f5a4355b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a>&gt; yask::yc_solution::get_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the grids in the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector containing pointer to all grids. </dd></dl>

</div>
</div>
<a class="anchor" id="ac78ee81c7aeb385cbdb7fa91c01bdf76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yc.html#ga3023a1e6cc90f33e357a9ec5d2ab3448">yc_grid_ptr</a> yask::yc_solution::get_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the specified grid. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the specified grid or null pointer if it does not exist. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1168b5b8044e39c047d81a5fe5efc06e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_fold_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the vectorization length in given dimension. </p>
<p>For YASK-code generation, the product of the fold lengths should be equal to the number of elements in a HW SIMD register. The number of elements in a HW SIMD register is determined by the number of bytes in an element and the print format. Example: For SP FP elements in AVX-512 vectors, the product of the fold lengths should be 16, e.g., x=4 and y=4. </p><dl class="section note"><dt>Note</dt><dd>If the product of the fold lengths is <em>not</em> the number of elements in a HW SIMD register, the fold lengths will be adjusted based on an internal heuristic. In this heuristic, any fold length that is &gt;1 is used as a hint to indicate where to apply folding. </dd>
<dd>
A fold can only be applied in a domain dimension. </dd>
<dd>
Default length is one (1) in each domain dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Dimension of fold, e.g., "x". This must be an index created by new_domain_index(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of vectorization in <code>dim</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf489e67ed8cc753e999b1495dd4dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::clear_folding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all vector-folding settings. </p>
<p>All fold lengths will return to the default of one (1). </p>

</div>
</div>
<a class="anchor" id="a45cb1df4af6886e82f98904473873272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_cluster_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yc.html#gac5a8be4a272d764b1145f1e0c6f493e0">yc_index_node_ptr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cluster multiplier (unroll factor) in given dimension. </p>
<p>For YASK kernel-code generation, this will have the effect of creating N vectors of output for each equation, where N is the product of the cluster multipliers.</p>
<dl class="section note"><dt>Note</dt><dd>A multiplier &gt;1 cannot be applied to the step dimension. </dd>
<dd>
Default is one (1) in each dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Direction of unroll, e.g., "y". This must be an index created by new_domain_index(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mult</td><td>Number of vectors in <code>dim</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4ddf5e4155d64cea2b39d5cb1e2435e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::clear_clustering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all vector-clustering settings. </p>
<p>All cluster multipliers will return to the default of one (1). </p>

</div>
</div>
<a class="anchor" id="a6094a75fe966ad339ffb034ea08674da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yc_solution::get_num_equations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of equations in the solution. </p>
<p>Equations are added when <a class="el" href="classyask_1_1yc__node__factory.html#a1da71b89d7fe25beeb044eb61f9efe0c" title="Create an equation node. ">yc_node_factory::new_equation_node()</a> is called. </p><dl class="section return"><dt>Returns</dt><dd>Number of equations that have been created. </dd></dl>

</div>
</div>
<a class="anchor" id="a8257de64334bd95fcaca64719653fd1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&gt; yask::yc_solution::get_equations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of all the defined equations. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of containing pointers to all equations that have been created. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e606a7a3a3d3fee9d5758095065fd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a>&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the current equation(s) and write to given output object. </p>
<p>Currently supported format types: </p><table class="doxtable">
<tr>
<th>Type </th><th>Output  </th></tr>
<tr>
<td>cpp </td><td>YASK stencil classes for generic C++. </td></tr>
<tr>
<td>avx </td><td>YASK stencil classes for CORE AVX ISA. </td></tr>
<tr>
<td>avx2 </td><td>YASK stencil classes for CORE AVX2 ISA. </td></tr>
<tr>
<td>avx512 </td><td>YASK stencil classes for CORE AVX-512 &amp; MIC AVX-512 ISAs. </td></tr>
<tr>
<td>knc </td><td>YASK stencil classes for Knights Corner ISA. </td></tr>
<tr>
<td>dot </td><td>DOT-language description. </td></tr>
<tr>
<td>dot-lite</td><td>DOT-language description of grid accesses only. </td></tr>
<tr>
<td>pseudo </td><td>Human-readable pseudo-code (for debug). </td></tr>
</table>
<p>Progress text will be written to the output stream set via <a class="el" href="classyask_1_1yc__solution.html#aff540803d358a5dcd304f09c522ec867" title="Set object to receive debug output. ">set_debug_output()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>"avx512f" is allowed as an alias for "avx512". </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><em>Side effect:</em> Applies optimizations to the equation(s), so some pointers to nodes in the original equations may refer to modified nodes or nodes that have been optimized away after calling <a class="el" href="classyask_1_1yc__solution.html#aa1e606a7a3a3d3fee9d5758095065fd2" title="Format the current equation(s) and write to given output object. ">format()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format_type</td><td>Name of type from above table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to object to receive formatted output. See <a class="el" href="classyask_1_1yask__output__factory.html">yask_output_factory</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac181c24ab7af945318a055cef3b52ee6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::set_dependency_checker_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Enable or disable automatic dependency checker. </p>
<p>Disabling the built-in dependency checker may be done when it is overly conservative. Currently, the provided checker does not allow stencils in which points in one sub-domain depend on points in another sub-domain within the same value of the step index.</p>
<dl class="section warning"><dt>Warning</dt><dd>If dependency checker is disabled, <em>all</em> dependencies must be set via <a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e" title="[Advanced] Add a dependency between two equations. ">add_flow_dependency()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><code>true</code> to enable or <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a894a0f5b85744190a56c1a64b5eaaff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yc_solution::is_dependency_checker_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine whether automatic dependency checker is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting. </dd></dl>

</div>
</div>
<a class="anchor" id="a727a91bb87e42de9822ac6540e3fc93e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::add_flow_dependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yc.html#ga42131f5a8cfbe95d98a131e25b1b86f3">yc_equation_node_ptr</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a dependency between two equations. </p>
<p>This function adds an arc in the data-dependency graph <code>from</code> one equation (node) <code>to</code> another one, indicating that the <code>from</code> equation depends on the <code>to</code> equation. In other words, the <code>to</code> expression must be evaluated <em>before</em> the <code>from</code> equation. In compiler-theory terms, this is a <em>flow</em> dependency, also known as a <em>true</em> or <em>read-after-write</em> (RAW) dependency. (Strictly speaking, however, equations in the YASK compiler are declarative instead of imperative, so they describe equalities rather than assignments with reads and writes. On the other hand, a C++ function created to implement one or more equations will perform analogous reads and writes.)</p>
<p>Additional considerations:</p>
<ul>
<li>It is not necessary to connect all the equations into a single graph. For example, if <b>A</b> depends on <b>B</b> and <b>C</b> depends on <b>D</b>, there will be two disconnected subgraphs. In this example, the YASK kernel is free to 1) schedule the functions created for B** and <b>D</b> to run together in parallel followed by those for A** and <b>C</b> together in parallel, 2) run a single function that implements both <b>B</b> and <b>D</b> simultaneously followed by a single function that implements both <b>A</b> and <b>C</b> simultaneously, or 3) a combination of the implementations.</li>
<li>Only <em>immediate</em> dependencies should be added. In other words, each subgraph created should be a transitive reduction. For example, if <b>A</b> depends on <b>B</b> and <b>B</b> depends on <b>C</b>, it is not necessary to add the transitive dependence from <b>A</b> to <b>C</b>.</li>
<li>Only dependencies at a given step-index value should be added. For example, given equation <b>A</b>: <code>A(t+1, x) EQUALS B(t+1, x) + 5</code> and equation <b>B</b>: <code>B(t+1, x) EQUALS A(t, x) / 2</code>, A** depends on <b>B</b> at some value of the step-index <code>t</code>. That dependency should be added if the automatic checker is disabled. (It is true that the next value of <code>B(t+2)</code> depends on <code>A(t+1)</code>, but such inter-step &ndash; analgous to loop-carried &ndash; dependencies should <em>not</em> be added with this function.)</li>
<li>The dependencies should create one or more directed acyclic graphs (DAGs). If a cycle is created, the YASK compiler will throw an exception containing an error message about a circular dependency. This exception may not be thrown until <a class="el" href="classyask_1_1yc__solution.html#aa1e606a7a3a3d3fee9d5758095065fd2" title="Format the current equation(s) and write to given output object. ">format()</a> is called.</li>
<li>If using scratch grids, dependencies among scratch grids and between scratch-grid equations and non-scratch-grid equations should also be added. Each scratch grid equation should ultimately depend on non-scratch-grid values.</li>
<li>This function can be used in cooperation with or instead of the built-in automatic dependency checker. When used in cooperation with the built-in checker, both dependencies from this function and the built-in checker will be considered. When the built-in checker is diabled via <code>set_dependency_checker_enabled(false)</code>, only dependencies from this function will be considered. In this case, it is imperative that all immediate dependencies are added. If the dependency graph is incomplete, the resulting generated stencil code will contain illegal race conditions, and it will most likely produce incorrect results. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Equation that must be evaluated <em>after</em> <code>to</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Equation that must be evaluated <em>before</em> <code>from</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42cd08d7a26c93d5073134f3b76dcc38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yc_solution::clear_dependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Remove all existing dependencies. </p>
<p>Removes dependencies added via <a class="el" href="classyask_1_1yc__solution.html#a727a91bb87e42de9822ac6540e3fc93e" title="[Advanced] Add a dependency between two equations. ">add_flow_dependency()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yask__compiler__api_8hpp_source.html">yask_compiler_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
